const myLog = (data) => console.log(data);

/** 13 ЧИСТІ ФУНКЦІЇ
Функція з побічними ефектами - це функція, яка в процесі виконання може 
змінювати або використовувати глобальні змінні, змінювати значення 
аргументів посилального типу, виконувати операції введення-виведення тощо.

const dirtyMultiply = (array, value) => {
  for (let i = 0; i < array.length; i += 1) {
    array[i] = array[i] * value;
  }
};

const numbers = [1, 2, 3, 4, 5];
dirtyMultiply(numbers, 2);
// Відбулася мутація вихідних даних - масиву numbers
console.log(numbers); // [2, 4, 6, 8, 10]

Функція dirtyMultiply(array, value) множить кожен елемент масиву array на 
число value. Вона змінює (мутує) вихідний масив за посиланням.

Чиста функція (pure function) - це функція, результат якої залежить тільки 
від значень переданих аргументів. За умови однакових аргументів вона завжди 
повертає один і той самий результат, і не має побічних ефектів, тобто не 
змінює значення аргументів.

Напишемо реалізацію чистої функції множення елементів масиву, що повертає 
новий масив, не змінюючи вихідний.

const pureMultiply = (array, value) => {
  const newArray = [];

  array.forEach(element => {
    newArray.push(element * value);
  });

  return newArray;
};

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = pureMultiply(numbers, 2);

// Мутація вихідних даних не відбулася
console.log(numbers); // [1, 2, 3, 4, 5]
// Функція повернула новий масив зі зміненими даними
console.log(doubledNumbers); // [2, 4, 6, 8, 10]


// ------------------------------------------------------------------------
Функція changeEven(numbers, value) приймає масив чисел numbers і оновлює 
кожен елемент, значення якого - це парне число, додаючи до нього значення 
параметра value.

Виконай рефакторинг функції таким чином, щоб вона стала чистою - не змінювала 
масив чисел numbers, а створювала, наповнювала і повертала новий масив з 
оновленими значеннями.
*/

// function changeEven(numbers, value) {
//   // Change code below this line
//   for (let i = 0; i < numbers.length; i += 1) {
//     if (numbers[i] % 2 === 0) {
//       numbers[i] = numbers[i] + value;
//     }
//   }
//   return numbers;
//   // Change code above this line
// }

// function changeEven(numbers, value) {
//   // Change code below this line
//   const newArray = [];

//   numbers.forEach((number) => {
//     number % 2 === 0 ? newArray.push(number + value) : newArray.push(number);
//   });

//   return newArray;
//   // Change code above this line
// }

// const changeEven = (numbers, value) => {
//   const newArray = [];

//   numbers.forEach((number) => {
//     // number % 2 === 0 ? newArray.push(number + value) : newArray.push(number);
//     if (number % 2 === 0) number += value;
//     newArray.push(number);
//   });

//   return newArray;
// };

// // ------------------------------------------------------------------------
// myLog(changeEven([1, 2, 3, 4, 5], 10)); //[1, 12, 3, 14, 5]
// myLog(changeEven([2, 8, 3, 7, 4, 6], 10)); //[12, 18, 3, 7, 14, 16]
// myLog(changeEven([17, 24, 68, 31, 42], 100)); //[17, 124, 168, 31, 142]
// myLog(changeEven([44, 13, 81, 92, 36, 54], 100)); // [144, 13, 81, 192, 136, 154]

// ========================================================================

/** 14 МЕТОД MAP()
Більшість перебираючих методів масиву - це чисті функції. Вони створюють 
новий масив, заповнюють його, застосовуючи до значення кожного елемента 
зазначену колбек-функцію, після чого повертають цей новий масив.

Метод map(callback) використовується для трансформації масиву. Він викликає 
колбек-функцію для кожного елемента вихідного масиву, а результат її роботи 
записує у новий масив, який і буде результатом виконання методу.

масив.map((element, index, array) => {
  // Тіло колбек-функції
});
Поелементо перебирає оригінальний масив.
Не змінює оригінальний масив.
Результат роботи колбек-функції записується у новий масив.
Повертає новий масив однакової довжини.

Його можна використовувати для того, щоб змінити кожен елемент масиву. 
Оригінальний масив використовується як еталон, на основі якого можна 
зробити іншу колекцію.

const planets = ["Earth", "Mars", "Venus", "Jupiter"];

const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
console.log(planetsInUpperCase); // ["EARTH", "MARS", "VENUS", "JUPITER"]

const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
console.log(planetsInLowerCase); // ["earth", "mars", "venus", "jupiter"]

// Оригінальний масив не змінився
console.log(planets); // ["Earth", "Mars", "Venus", "Jupiter"]

Використання анонімних стрілочних функцій з неявним поверненням суттєво 
скорочує «шум» оголошення колбек-функції, що робить код чистішим і 
простішим для сприйняття. 

// ------------------------------------------------------------------------
Доповни код таким чином, щоб у змінній planetsLengths вийшов масив довжин 
назв планет. Обов'язково використовуй метод map().
*/

// const planets = ['Earth', 'Mars', 'Venus', 'Jupiter'];
// // Change code below this line
// // const planetsLengths = planets;
// const planetsLengths = planets.map((planet) => planet.length);

// // ------------------------------------------------------------------------
// myLog(planetsLengths); //[5, 4, 5, 7]

// ========================================================================

/** 15 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================

/** 13 */

// ========================================================================
